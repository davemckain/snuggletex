<!--

$Id$

This stylesheet enhances a raw Presentation MathML <math/> element
generated by SnuggleTeX, attempting to infer semantics within basic
mathematical expressions.

This is the first step in any attempts to up-convert to Content MathML
or Maxima input.

TODO: Think about plus-or-minus operator??
TODO: Other infix operators from set theory such as \in and stuff like that?
TODO: Should we specify precedence for other infix operators? (Later... nothing to do with MathAssess... actually maybe not!)
TODO: <mstyle/> is essentially being treated as neutering its contents... is this a good idea? It's a hard problem to solve in general.

Copyright (c) 2009 The University of Edinburgh
All Rights Reserved

-->
<xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:s="http://www.ph.ed.ac.uk/snuggletex"
  xmlns:sho="http://www.ph.ed.ac.uk/snuggletex/higher-order"
  xmlns:sp="http://www.ph.ed.ac.uk/snuggletex/pmathml"
  xmlns:local="http://www.ph.ed.ac.uk/snuggletex/pmathml-enhancer"
  xmlns:m="http://www.w3.org/1998/Math/MathML"
  xmlns="http://www.w3.org/1998/Math/MathML"
  exclude-result-prefixes="xs m s sho sp local"
  xpath-default-namespace="http://www.w3.org/1998/Math/MathML">

  <xsl:strip-space elements="m:*"/>

  <!-- ************************************************************ -->

  <!-- Entry point -->
  <xsl:template name="s:enhance-pmathml">
    <xsl:param name="elements" as="element()*"/>
    <xsl:call-template name="local:process-group">
      <xsl:with-param name="elements" select="$elements"/>
    </xsl:call-template>
  </xsl:template>

  <!-- ************************************************************ -->

  <xsl:variable name="sp:invertible-elementary-functions" as="xs:string+"
    select="('sin', 'cos', 'tan',
             'sec', 'csc' ,'cot',
             'sinh', 'cosh', 'tanh',
             'sech', 'csch', 'coth')"/>

  <xsl:variable name="sp:elementary-functions" as="xs:string+"
    select="($sp:invertible-elementary-functions,
            'arcsin', 'arccos', 'arctan',
            'arcsec', 'arccsc', 'arccot',
            'arcsinh', 'arccosh', 'arctanh',
            'arcsech', 'arccsch', 'arccoth',
            'ln', 'log', 'exp')"/>

  <xsl:variable name="sp:explicit-multiplication-characters" as="xs:string+"
    select="('*', '&#xd7;', '&#x22c5;')"/>

  <!-- TEMP: I'm going to all \forall (U+2200) temporarily until I get all of this working -->
  <xsl:variable name="sp:prefix-operators" as="xs:string+"
    select="('&#x2200;')"/>

  <!-- NOTE: Currently, the only postfix operator is factorial, which is handled in a special way.
       But I'll keep this more general logic for the time being as it gives nicer symmetry with prefix
       operators. -->
  <xsl:variable name="sp:postfix-operators" as="xs:string+"
    select="('!')"/>

  <xsl:function name="sp:is-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo])"/>
  </xsl:function>

  <xsl:function name="sp:is-infix-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:variable name="previous" as="element()?" select="$element/preceding-sibling::*[1]"/>
    <xsl:sequence select="sp:is-operator($element) and exists($previous) and not(sp:is-operator($previous))"/>
  </xsl:function>

  <xsl:function name="sp:is-plus-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and .='+'])"/>
  </xsl:function>

  <xsl:function name="sp:is-minus-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and .='-'])"/>
  </xsl:function>

  <xsl:function name="sp:is-divide-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and .='/'])"/>
  </xsl:function>

  <xsl:function name="sp:is-factorial-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and .='!'])"/>
  </xsl:function>

  <xsl:function name="sp:is-explicit-multiplication" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and $sp:explicit-multiplication-characters=string(.)])"/>
  </xsl:function>

  <xsl:function name="sp:is-elementary-function" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mi and $sp:elementary-functions=string(.)])"/>
  </xsl:function>

  <!-- Tests for the equivalent of \sin, \sin^{.} or \log_a. Result need not make any actual sense! -->
  <xsl:function name="sp:is-supported-function" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="sp:is-elementary-function($element)
      or $element[self::msup and sp:is-elementary-function(*[1])]
      or $element[self::msub and *[1][self::mi and .='log']]"/>
  </xsl:function>

  <xsl:function name="sp:is-prefix-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and $sp:prefix-operators=string(.)])"/>
  </xsl:function>

  <xsl:function name="sp:is-prefix-or-function" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean(sp:is-supported-function($element) or sp:is-prefix-operator($element))"/>
  </xsl:function>

  <xsl:function name="sp:is-postfix-operator" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and $sp:postfix-operators=string(.)])"/>
  </xsl:function>

  <xsl:function name="sp:is-default-group-starter" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <!--
    An element starts a "default group" if:

    1. It is either the first in a sequence of siblings
    OR 2. It is a prefix operator and doesn't immediately follow a prefix operator
    OR 3. It is neither a prefix nor postfix operator and follows a postfix operator

    -->
    <xsl:variable name="previous" as="element()?" select="$element/preceding-sibling::*[1]"/>
    <xsl:sequence select="boolean(
      not(exists($previous))
      or (sp:is-prefix-or-function($element) and not(sp:is-prefix-or-function($previous)))
      or (not(sp:is-prefix-or-function($element)) and not(sp:is-postfix-operator($element))
        and sp:is-postfix-operator($previous)))"/>
  </xsl:function>

  <!-- ************************************************************ -->
  <!-- Templates for explicit MathML elements -->

  <!-- Container elements with unrestricted content -->
  <xsl:template match="mrow|msqrt" mode="enhance-pmathml">
    <!-- Process contents as normal -->
    <xsl:variable name="processed-contents" as="element()*">
      <xsl:call-template name="local:process-group">
        <xsl:with-param name="elements" select="*"/>
      </xsl:call-template>
    </xsl:variable>
    <!-- If contents consists of a single <mrow/>, strip it off and descend down -->
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:choose>
        <xsl:when test="count($processed-contents)=1 and $processed-contents[1][self::mrow]">
          <xsl:copy-of select="$processed-contents/*"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:copy-of select="$processed-contents"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:copy>
  </xsl:template>

  <!-- Default template for other MathML elements -->
  <xsl:template match="*" mode="enhance-pmathml">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="enhance-pmathml"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="text()" mode="enhance-pmathml">
    <xsl:copy-of select="."/>
  </xsl:template>

  <!-- ************************************************************ -->
  <!-- "Higher-order function" templates to make certain groupings easy -->

  <xsl:function name="local:apply-matcher">
    <xsl:param name="matcher-reference" as="element()"/>
    <xsl:param name="element" as="element()"/>
    <xsl:apply-templates select="$sp:is-equals">
      <xsl:with-param name="element" select="$element"/>
    </xsl:apply-templates>
  </xsl:function>

  <xsl:function name="sp:is-equals" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="boolean($element[self::mo and .='='])"/>
  </xsl:function>

  <xsl:template match="sho:is-equals" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:sequence select="sp:is-equals($element)"/>
  </xsl:template>

  <xsl:variable name="sp:is-equals" as="element()">
    <sho:is-equals/>
  </xsl:variable>

  <xsl:function name="local:is-matching-infix-mo" as="xs:boolean">
    <xsl:param name="element" as="element()"/>
    <xsl:param name="mo-matches" as="xs:string+"/>
    <xsl:sequence select="boolean(sp:is-infix-operator($element) and $element=$mo-matches)"/>
  </xsl:function>

  <!-- Groups an associative infix <mo/> operator -->
  <xsl:template name="local:group-associative-infix-mo">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:param name="mo-matches" as="xs:string+" required="yes"/>
    <xsl:for-each-group select="$elements" group-adjacent="local:is-matching-infix-mo(., $mo-matches)">
      <xsl:choose>
        <xsl:when test="current-grouping-key()">
          <!-- Copy the matching operator -->
          <xsl:copy-of select="."/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="s:maybe-wrap-in-mrow">
            <xsl:with-param name="elements" as="element()*">
              <xsl:call-template name="local:process-group">
                <xsl:with-param name="elements" select="current-group()"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:template>

  <!-- Groups a left- but not right-associative infix <mo/> operator -->
  <xsl:template name="local:group-left-associative-infix-mo">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:param name="mo-matches" as="xs:string+" required="yes"/>
    <xsl:variable name="operators" select="$elements[local:is-matching-infix-mo(., $mo-matches)]" as="element()+"/>
    <xsl:variable name="operator-count" select="count($operators)" as="xs:integer"/>
    <xsl:choose>
      <xsl:when test="$operator-count != 1">
        <!-- Something like 'a o b o c'. We handle this recursively as '(a o b) o c' -->
        <xsl:variable name="last-operator" select="$operators[position()=last()]" as="element()"/>
        <xsl:variable name="before-last-operator" select="$elements[. &lt;&lt; $last-operator]" as="element()+"/>
        <xsl:variable name="after-last-operator" select="$elements[. &gt;&gt; $last-operator]" as="element()*"/>
        <mrow>
          <xsl:call-template name="local:group-left-associative-infix-mo">
            <xsl:with-param name="elements" select="$before-last-operator"/>
            <xsl:with-param name="mo-matches" select="$mo-matches"/>
          </xsl:call-template>
        </mrow>
        <xsl:copy-of select="$last-operator"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$after-last-operator"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- Only one operator, so it'll be 'a o b' (or more pathologically 'a o').
             We will allow the pathological cases here. -->
        <xsl:variable name="operator" select="$operators[1]" as="element()"/>
        <xsl:variable name="left-operand" select="$elements[. &lt;&lt; $operator]" as="element()+"/>
        <xsl:variable name="right-operand" select="$elements[. &gt;&gt; $operator]" as="element()*"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$left-operand"/>
        </xsl:call-template>
        <xsl:copy-of select="$operator"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$right-operand"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="local:process-group">
    <xsl:param name="elements" as="element()*" required="yes"/>
    <xsl:choose>
      <xsl:when test="$elements[local:is-matching-infix-mo(., ('='))]">
        <!-- Equals -->
        <xsl:call-template name="local:group-associative-infix-mo">
          <xsl:with-param name="elements" select="$elements"/>
          <xsl:with-param name="mo-matches" select="('=')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[local:is-matching-infix-mo(., ('+'))]">
        <!-- Infix Addition -->
        <xsl:call-template name="local:group-associative-infix-mo">
          <xsl:with-param name="elements" select="$elements"/>
          <xsl:with-param name="mo-matches" select="('+')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[local:is-matching-infix-mo(., ('-'))]">
        <!-- Infix Subtraction -->
        <xsl:call-template name="local:group-left-associative-infix-mo">
          <xsl:with-param name="elements" select="$elements"/>
          <xsl:with-param name="mo-matches" select="('-')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[1][sp:is-plus-operator(.) or sp:is-minus-operator(.)]">
        <!-- Special case of '+' or '-' Operator used in prefix mode -->
        <xsl:call-template name="local:handle-prefix-group">
          <xsl:with-param name="elements" select="$elements"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[local:is-matching-infix-mo(., $sp:explicit-multiplication-characters)]">
        <!-- Explicit Multiplication, detected in various ways -->
        <xsl:call-template name="local:group-associative-infix-mo">
          <xsl:with-param name="elements" select="$elements"/>
          <xsl:with-param name="mo-matches" select="$sp:explicit-multiplication-characters"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[local:is-matching-infix-mo(., ('/'))]">
        <!-- Explicit Division -->
        <xsl:call-template name="local:group-left-associative-infix-mo">
          <xsl:with-param name="elements" select="$elements"/>
          <xsl:with-param name="mo-matches" select="('/')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$elements[self::mspace]">
        <!-- Any <mspace/> is kept but interpreted as an implicit multiplication as well -->
        <xsl:call-template name="local:handle-mspace-group">
          <xsl:with-param name="elements" select="$elements"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="count($elements) &gt; 1">
        <!-- Need to infer function applications and multiplications, leave other operators as-is -->
        <xsl:call-template name="local:handle-default-group">
          <xsl:with-param name="elements" select="$elements"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="count($elements)=1">
        <!-- "Atom" -->
        <xsl:apply-templates select="$elements[1]" mode="enhance-pmathml"/>
      </xsl:when>
      <xsl:when test="empty($elements)">
        <!-- Empty -> empty -->
      </xsl:when>
      <xsl:otherwise>
        <!-- Based on the logic above, this can't actually happen! -->
        <xsl:message terminate="yes">
          Unexpected logic branch in local:process-group template
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Infix Subtraction Expression. Need to be more careful here as it is not associative -->
  <xsl:template name="local:handle-infix-subtraction-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:variable name="minus-count" select="count($elements[sp:is-infix-operator(.) and sp:is-minus-operator(.)])" as="xs:integer"/>
    <xsl:choose>
      <xsl:when test="$minus-count != 1">
        <!-- Something like 'a-b-c'. We handle this recursively as '(a-b)-c' -->
        <xsl:variable name="last-minus" select="$elements[sp:is-infix-operator(.) and sp:is-minus-operator(.)][position()=last()]" as="element()"/>
        <xsl:variable name="before-last-minus" select="$elements[. &lt;&lt; $last-minus]" as="element()+"/>
        <xsl:variable name="after-last-minus" select="$elements[. &gt;&gt; $last-minus]" as="element()*"/>
        <mrow>
          <xsl:call-template name="local:handle-infix-subtraction-group">
            <xsl:with-param name="elements" select="$before-last-minus"/>
          </xsl:call-template>
        </mrow>
        <xsl:copy-of select="$last-minus"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$after-last-minus"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- Only one minus, so it'll be 'a-b' (or more pathologically 'a-').
             We will allow the pathological cases here. -->
        <xsl:variable name="minus" select="$elements[sp:is-infix-operator(.) and sp:is-minus-operator(.)]" as="element()"/>
        <xsl:variable name="left-operand" select="$elements[. &lt;&lt; $minus]" as="element()+"/>
        <xsl:variable name="right-operand" select="$elements[. &gt;&gt; $minus]" as="element()*"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$left-operand"/>
        </xsl:call-template>
        <xsl:copy-of select="$minus"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$right-operand"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Explicit multiplication -->
  <xsl:template name="local:handle-explicit-multiplication-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:for-each-group select="$elements" group-adjacent="sp:is-explicit-multiplication(.)">
      <xsl:choose>
        <xsl:when test="current-grouping-key()">
          <xsl:copy-of select="."/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="s:maybe-wrap-in-mrow">
            <xsl:with-param name="elements" as="element()*">
              <xsl:call-template name="local:process-group">
                <xsl:with-param name="elements" select="current-group()"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:template>

  <!-- Division. This works similarly to subtraction -->
  <xsl:template name="local:handle-division-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:variable name="minus-count" select="count($elements[sp:is-divide-operator(.)])" as="xs:integer"/>
    <xsl:choose>
      <xsl:when test="$minus-count != 1">
        <!-- Something like 'a/b/c'. We handle this recursively as '(a/b)/c' -->
        <xsl:variable name="last-divide" select="$elements[sp:is-divide-operator(.)][position()=last()]" as="element()"/>
        <xsl:variable name="before-last-divide" select="$elements[. &lt;&lt; $last-divide]" as="element()+"/>
        <xsl:variable name="after-last-divide" select="$elements[. &gt;&gt; $last-divide]" as="element()*"/>
        <mrow>
          <xsl:call-template name="local:handle-division-group">
            <xsl:with-param name="elements" select="$before-last-divide"/>
          </xsl:call-template>
        </mrow>
        <xsl:copy-of select="$last-divide"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$after-last-divide"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- Only one divide, so it'll be 'a/b' (or more pathologically 'a/').
             We will allow the pathological cases here. -->
        <xsl:variable name="divide" select="$elements[sp:is-divide-operator(.)]" as="element()"/>
        <xsl:variable name="left-operand" select="$elements[. &lt;&lt; $divide]" as="element()+"/>
        <xsl:variable name="right-operand" select="$elements[. &gt;&gt; $divide]" as="element()*"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$left-operand"/>
        </xsl:call-template>
        <xsl:copy-of select="$divide"/>
        <xsl:call-template name="local:process-group">
          <xsl:with-param name="elements" select="$right-operand"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Prefix operator -->
  <xsl:template name="local:handle-prefix-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <mrow>
      <xsl:copy-of select="$elements[1]"/>
      <xsl:call-template name="s:maybe-wrap-in-mrow">
        <xsl:with-param name="elements" as="element()*">
          <xsl:call-template name="local:process-group">
            <xsl:with-param name="elements" select="$elements[position()!=1]"/>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>
    </mrow>
  </xsl:template>

  <!-- <mspace/> as explicit multiplication -->
  <xsl:template name="local:handle-mspace-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:for-each-group select="$elements" group-adjacent="boolean(self::mspace)">
      <xsl:choose>
        <xsl:when test="current-grouping-key()">
          <xsl:copy-of select="."/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="position()!=1">
            <!-- Add in InvisibleTimes -->
            <mo>&#x2062;</mo>
          </xsl:if>
          <!-- Then process as normal -->
          <xsl:call-template name="s:maybe-wrap-in-mrow">
            <xsl:with-param name="elements" as="element()*">
              <xsl:call-template name="local:process-group">
                <xsl:with-param name="elements" select="current-group()"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:template>

  <xsl:template name="local:handle-default-group">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:for-each-group select="$elements" group-starting-with="*[sp:is-default-group-starter(.)]">
      <!-- Add an invisible times if we're the second multiplicative group -->
      <xsl:if test="position()!=1">
        <mo>&#x2062;</mo>
      </xsl:if>
      <!-- Apply prefix operators and functions from start of group -->
      <xsl:call-template name="s:maybe-wrap-in-mrow">
        <xsl:with-param name="elements" as="element()*">
          <xsl:call-template name="local:apply-prefix-functions-and-operators">
            <xsl:with-param name="elements" select="current-group()"/>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:for-each-group>
  </xsl:template>

  <xsl:template name="local:apply-prefix-functions-and-operators">
    <xsl:param name="elements" as="element()+" required="yes"/>
    <xsl:variable name="first-element" as="element()" select="$elements[1]"/>
    <xsl:variable name="after-first-element" as="element()*" select="$elements[position()!=1]"/>
    <xsl:choose>
      <xsl:when test="sp:is-supported-function($first-element) and exists($after-first-element)">
        <!-- This is a (prefix) function application. Copy the operator as-is -->
        <xsl:copy-of select="$first-element"/>
        <!-- Add an "Apply Function" operator -->
        <mo>&#x2061;</mo>
        <!-- Process the rest recursively -->
        <xsl:call-template name="local:apply-prefix-functions-and-operators">
          <xsl:with-param name="elements" select="$after-first-element"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="sp:is-prefix-operator($first-element)">
        <!-- This is a prefix operator. Apply to everything that follows. -->
        <xsl:copy-of select="$first-element"/>
        <xsl:call-template name="local:apply-prefix-functions-and-operators">
          <xsl:with-param name="elements" select="$after-first-element"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- This is everything after any prefixes but before any postfixes -->
        <xsl:call-template name="s:maybe-wrap-in-mrow">
          <xsl:with-param name="elements" as="element()*">
            <xsl:call-template name="local:apply-postfix-operators">
              <xsl:with-param name="elements" select="$elements"/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="local:apply-postfix-operators">
    <xsl:param name="elements" as="element()*" required="yes"/>
    <xsl:variable name="last-element" as="element()?" select="$elements[position()=last()]"/>
    <xsl:variable name="before-last-element" as="element()*" select="$elements[position()!=last()]"/>
    <xsl:choose>
      <xsl:when test="$last-element[sp:is-factorial-operator(.)]">
        <!-- The factorial operator only binds to the last resulting subexpression -->
        <xsl:call-template name="local:apply-factorial">
          <xsl:with-param name="elements" as="element()*">
            <xsl:call-template name="local:apply-postfix-operators">
              <xsl:with-param name="elements" select="$before-last-element"/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$last-element[sp:is-postfix-operator(.)]">
        <!-- General Postfix operator. Bind to everything preceding -->
        <xsl:call-template name="local:apply-postfix-operators">
          <xsl:with-param name="elements" select="$before-last-element"/>
        </xsl:call-template>
        <xsl:copy-of select="$last-element"/>
      </xsl:when>
      <xsl:otherwise>
        <!-- We're in the "middle" of the expression, which we assume is implicit multiplication -->
        <xsl:call-template name="local:handle-implicit-multiplicative-group">
          <xsl:with-param name="elements" select="$elements"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="local:apply-factorial">
    <xsl:param name="elements" as="element()*" required="yes"/>
    <xsl:variable name="last-element" as="element()?" select="$elements[position()=last()]"/>
    <xsl:variable name="before-last-element" as="element()*" select="$elements[position()!=last()]"/>
    <xsl:copy-of select="$before-last-element"/>
    <xsl:choose>
      <xsl:when test="$last-element[self::mrow]">
        <mrow>
          <xsl:copy-of select="$last-element/*[position()!=last()]"/>
          <mrow>
            <xsl:copy-of select="$last-element/*[position()=last()]"/>
            <mo>!</mo>
          </mrow>
        </mrow>
      </xsl:when>
      <xsl:when test="exists($last-element)">
        <mrow>
          <xsl:copy-of select="$last-element"/>
          <mo>!</mo>
        </mrow>
      </xsl:when>
      <xsl:otherwise>
        <mo>!</mo>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="local:handle-implicit-multiplicative-group">
    <xsl:param name="elements" as="element()*" required="yes"/>
    <xsl:call-template name="s:maybe-wrap-in-mrow">
      <xsl:with-param name="elements" as="element()*">
        <xsl:for-each select="$elements">
          <xsl:if test="position()!=1">
            <!-- Add an "Invisible Times" -->
            <mo>&#x2062;</mo>
          </xsl:if>
          <!-- Descend into the element itself -->
          <xsl:apply-templates select="." mode="enhance-pmathml"/>
        </xsl:for-each>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>

  <!-- ************************************************************ -->

  <xsl:template name="s:maybe-wrap-in-mrow">
    <xsl:param name="elements" as="element()*" required="yes"/>
    <xsl:choose>
      <xsl:when test="count($elements)=1">
        <xsl:copy-of select="$elements"/>
      </xsl:when>
      <xsl:otherwise>
        <mrow>
          <xsl:copy-of select="$elements"/>
        </mrow>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>

